## 工厂模式

观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个目标对象，当这个目标对象的状态发生变化时，会通知所有观察者对象，使它们能够自动更新

首先我们来看这个代表发布者的类，我们给它起名叫 Publisher。这个类应该具备哪些“基本技能”呢？大家回忆一下上文中的韩梅梅，韩梅梅的基本操作是什么？首先是拉群（增加订阅者），然后是@所有人（通知订阅者），这俩是最明显的了。此外作为群主&产品经理，韩梅梅还具有踢走项目组成员（移除订阅者）的能力。OK，产品经理发布者类的三个基本能力齐了，下面我们开始写代码

```js
class Publisher {
  constructor() {
    this.observers = []
    console.log('publisher created')
  }

  add(observer) {
    console.log('publisher add invoked')
    this.observers.push(observer)
  }

  remove(observer) {
    console.log('publisher remove invoked')
    this.observers.forEach((item, i) => {
      if (item === observer) {
        this.observers.splice(i, 1)
      }
    })
  }

  notify() {
    console.log('publisher notify invoked')
    this.observers.forEach(observer => {
      observer.update(this)
    })
  }
}
```

我们一起来想想订阅者能干啥——其实订阅者的能力非常简单，作为被动的一方，它的行为只有两个——被通知、去执行（本质上是接受发布者的调用，这步我们在 Publisher 中已经做掉了）。既然我们在 Publisher 中做的是方法调用

```js
class Observer {
  constructor() {
    console.log('Observer created')
  }

  update() {
    console.log('Observer update invoked')
  }
}
```

```js
class PrdPublisher extends Publisher {
  constructor() {
    super()
    this.prdState = null // 初始化需求文档
    this.observers = [] // 韩梅梅还没有拉群，开发群目前为空
    console.log('PrdPublisher created')
  }
  // 该方法用于获取当前的prdState
  getState() {
    console.log('PrdPublisher getState invoked')
    return this.prdState
  }
  // 该方法用于改变prdState的值
  setState(state) {
    console.log('PrdPublisher setState invoked')
    this.prdState = state // prd的值发生改变
    this.notify() // 需求文档变更，立刻通知所有开发者
  }
}

// 接收需求文档、并开始干活
class DeveloperObserver extends Observer {
  constructor() {
    super()
    this.prdState = {} // 需求文档一开始还不存在，prd初始为空对象
    console.log('DeveloperObserver created')
  }
  // 重写一个具体的update方法
  update(publisher) {
    console.log('DeveloperObserver.update invoked')
    this.prdState = publisher.getState() // 更新需求文档
    this.work() // 调用工作函数
  }
  // work方法，一个专门搬砖的方法
  work() {
    const prd = this.prdState // 获取需求文档
    console.log('996 begins...') // 开始基于需求文档提供的信息搬砖。。。
  }
}
```

下面，我们可以 new 一个 PrdPublisher 对象（产品经理），她可以通过调用 setState 方法来更新需求文档。需求文档每次更新，都会紧接着调用 notify 方法来通知所有开发者，这就实现了定义里所谓的：

目标对象的状态发生变化时，会通知所有观察者对象，使它们能够自动更新

```js

// 创建订阅者：前端开发李雷
const liLei = new DeveloperObserver()
// 创建订阅者：服务端开发小A（sorry。。。起名字真的太难了）
const A = new DeveloperObserver()
// 创建订阅者：测试同学小B
const B = new DeveloperObserver()
// 韩梅梅出现了
const hanMeiMei = new PrdPublisher()
// 需求文档出现了
const prd = {
    // 具体的需求内容
    ...
}
// 韩梅梅开始拉群
hanMeiMei.add(liLei)
hanMeiMei.add(A)
hanMeiMei.add(B)
// 韩梅梅发送了需求文档，并@了所有人
hanMeiMei.setState(prd)

```

### Vue 的观察者模式运用

```js
// 监听器，对需要监听的数据对象进行遍历，给他的属性加上定制的getter和setter函数，这样当数据发生了改变，就会触发setter函数，从而通知到订阅者，这个setter函数就是我们的监听器
// observe方法遍历并包装对象属性
function observe(target) {
  // 若target是一个对象，则遍历它
  if (target && typeof target === 'object') {
    Object.keys(target).forEach(key => {
      // defineReactive方法会给目标属性装上“监听器”
      defineReactive(target, key, target[key])
    })
  }
}

// 定义defineReactive方法
function defineReactive(target, key, val) {
  // 属性值也可能是object类型，这种情况下需要调用observe进行递归遍历
  observe(val)
  // 为当前属性安装监听器
  Object.defineProperty(target, key, {
    // 可枚举
    enumerable: true,
    // 不可配置
    configurable: false,
    get: function() {
      return val
    },
    // 监听器函数
    set: function(value) {
      console.log(`${target}属性的${key}属性从${val}值变成了了${value}`)
      val = value
    }
  })
}

// 定义订阅者类Dep
class Dep {
  constructor() {
    // 初始化订阅队列
    this.subs = []
  }

  // 增加订阅者
  addSub(sub) {
    this.subs.push(sub)
  }

  // 通知订阅者（是不是所有的代码都似曾相识？）
  notify() {
    this.subs.forEach(sub => {
      sub.update()
    })
  }
}

// 改写defineReactive中的setter方法，在监听器里去通知订阅者
function defineReactive(target, key, val) {
  const dep = new Dep()
  // 监听当前属性
  observe(val)
  Object.defineProperty(target, key, {
    set: value => {
      // 通知所有订阅者
      dep.notify()
    }
  })
}
```
