## 工厂模式

将创建对象的过程单独封装，有构造函数的地方，我们就应该想到工厂模式。而构造器解决的是多个对象实例的问题，那么当复杂度从多个类共存上升到多个工厂共存时应该怎么处理？

简单的工厂函数：

```js

function Factory(name, age, career) {
  let work
  switch (career) {
    case 'corder':
      work = ['写代码', '写系分', '修bug']
      break
    case 'product manager':
      work = ['订会议室', '写PRD', '催更']
      break
    case 'boss':
      work = ['喝茶', '看报', '见客户']
    case 'xxx':
      // 其它工种的职责分配
      ...
  }
  return new User(name, age, career, work)  // 构造函数
}

```

抽象工厂模式

```js
class MobilePhoneFactory {
  // 提供操作系统的接口
  creteOS() {
    throw new Error('抽象工厂方法不允许直接调用，你需要将我重写')
  }
  createHardWare() {
    throw new Error('抽象工厂方法不允许直接调用，你需要将我重写')
  }
}
```

抽象工厂不干活，具体工厂来干活：

```js

class FakeStarFactory extends MobilePhoneFactory {
  createOS() {
    // 提供安卓系统实例
    return new AndroidOS()
  }
  createHardWare() {
    // 提供高通硬件实例

    return new QualcommHardWare()
  }
}

```
